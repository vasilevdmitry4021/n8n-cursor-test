# USER STORY: Управление заявками ТО через TORO Maintenance Orders API

Документ описывает пользовательскую историю, составленную на основе актуального `USER_GUIDE_2.md` и реализованного API в репозитории.

## 1. Контекст и заинтересованные стороны
- **Основной пользователь**: диспетчер по ремонту оборудования производственного предприятия.
- **Вторичные пользователи**: мастера цехов (подают заявки), интеграции n8n/фронтенд (автоматизируют ввод данных), ИТ-администратор (поддерживает инфраструктуру).
- **Проблема**: заявки на ремонт приходят в разных каналах, теряются и не имеют прозрачного статуса.
- **Цель**: централизовать регистрацию, отслеживание и выдачу статусов заявок через единый REST API.

## 2. User Story (формат As a / I want / So that)
> **As a** диспетчер по ремонту  
> **I want** создавать и просматривать заявки на обслуживание через `/api/v1/orders`  
> **So that** каждый запрос от цехов фиксируется c уникальным номером TORO-YYYY-NNN и контролируемым статусом.

## 3. Описание потока
1. Пользователь аутентифицируется во внутреннем инструменте, который обращается к API.
2. При получении запроса на ремонт диспетчер отправляет `POST /api/v1/orders` с обязательными полями (`equipment_type`, `equipment_id`, `issue_description`, `requester_name`, `department`, `contact_phone`, `contact_email`) и опциональным `priority`.
3. Сервис:
   - нормализует текстовые поля, проверяет телефон по маске `+7-XXX-XXX-XX-XX`;
   - выставляет `status=created` и генерирует `order_number` формата `TORO-YYYY-NNN`;
   - сохраняет заявку в БД `toro.db` через SQLAlchemy.
4. Диспетчер или мастер контролирует прогресс через:
   - `GET /api/v1/orders` — со списками и фильтрами по `priority/status/department`;
   - `GET /api/v1/orders/<id>` — для детального просмотра и последующего обновления (в следующих итерациях).

## 4. Acceptance Criteria
- **Создание заявки**
  - GIVEN корректное тело запроса, WHEN отправляется `POST /api/v1/orders`, THEN API возвращает `201` и JSON с заполненными полями, включая `order_number`, `status="created"`, метки времени.
  - GIVEN отсутствует обязательное поле, email некорректен или телефон вне формата, WHEN выполняется запрос, THEN API возвращает `400` с `error="validation_error"` и деталями по каждому полю.
- **Список заявок**
  - GIVEN БД содержит записи, WHEN выполняется `GET /api/v1/orders` без фильтров, THEN сервис возвращает массив `orders` в порядке `created_at` DESC и `total` равный количеству записей.
  - GIVEN применены query-параметры `priority`, `status`, `department`, WHEN вызывается список, THEN выдаются только записи, удовлетворяющие всем переданным фильтрам, иначе `400` с пояснениями.
- **Получение по ID**
  - GIVEN существует запись с `id`, WHEN вызывается `GET /api/v1/orders/<id>`, THEN ответ `200` содержит точную копию полей.
  - GIVEN запись отсутствует, THEN API отвечает `404` c сообщением `Order not found`.
- **Нефункциональные**
  - Логи формируются в формате `timestamp | level | logger | message`.
  - CORS включён для всех источников в дев-среде; перед продом возможно ограничение.

## 5. Definition of Ready
- Уточнены источники заявок и формат телефона.
- Настроена окружение Python 3.11+, виртуальное окружение и зависимости (`requirements.txt`).
- Определён хост БД (`TORO_DATABASE_URL`) и стратегия резервного копирования `toro.db`.

## 6. Definition of Done
- Все Acceptance Criteria удовлетворены вручную либо curl-тестами из `USER_GUIDE_2.md`, включая проверку email и телефона.
- Ошибки 4xx/5xx логируются, а `db.create_all()` выполнялся без исключений при старте.
- README содержит актуальные инструкции по запуску, а код сопровождается минимально необходимыми комментариями.
- Проведены smoke-тесты: `POST` создание + `GET` список.

## 7. Ссылки
- Руководство пользователя: `USER_GUIDE_2.md`
- API спецификация: `TORO_API_SPEC.md`
- Исполнение: `app.py`, `database.py`, `models.py`
