# Руководство пользователя: TORO Maintenance Orders API

Документ описывает, как развернуть и использовать API для учета заявок на техническое обслуживание оборудования. Руководство составлено на основе реализации в репозитории `n8n-cursor-test` и отражает фактическое поведение приложения.

## 1. Назначение сервиса
- Прием заявок на ремонт/ТО от производственных подразделений.
- Контроль статуса и приоритета заказов.
- Предоставление простого REST API для интеграции с фронтендом, n8n или другими системами.

## 2. Архитектура и стек
- **Язык**: Python 3.11+
- **Веб-фреймворк**: Flask
- **ORM**: Flask-SQLAlchemy
- **Валидация**: Pydantic 2.x
- **База данных**: SQLite (файл `toro.db`, создается автоматически)
- **CORS**: Flask-CORS (по умолчанию разрешает все источники для упрощения разработки)

Основные файлы:
- `app.py` — Flask-приложение, маршруты `/api/v1/orders`.
- `database.py` — инициализация SQLAlchemy, чтение `TORO_DATABASE_URL`.
- `models.py` — модель `Order`, сериализация в JSON.
- `requirements.txt` — список зависимостей.

## 3. Системные требования
- Python 3.11 или новее.
- `pip` для установки зависимостей.
- 100 МБ свободного места (для виртуального окружения и базы данных).
- Доступ к сети (опционально) для установки пакетов.

## 4. Установка
```bash
git clone <repo_url> toro-api
cd toro-api
python -m venv .venv
source .venv/bin/activate      # Windows: .venv\Scripts\activate
pip install -r requirements.txt
```

При необходимости переопределите путь к БД:
```bash
export TORO_DATABASE_URL="sqlite:////tmp/toro.db"
```
> После добавления новых полей (например, `contact_email`) удалите старый `toro.db`, чтобы SQLAlchemy пересоздал таблицы.

## 5. Запуск
```bash
source .venv/bin/activate
python app.py
# Приложение слушает http://localhost:5000
```

При первом запуске автоматически создаётся база и таблица `orders`. В логе появится строка вида:
```
2025-11-25 10:15:30 | INFO | toro.api | Created order TORO-2025-001 (...)
```

## 6. Проверка работоспособности
1. Создайте заявку:
   ```bash
   curl -X POST http://localhost:5000/api/v1/orders \
     -H "Content-Type: application/json" \
     -d '{
           "equipment_type": "Токарный станок",
           "equipment_id": "LAT-042",
           "issue_description": "Не работает подача резца",
           "priority": "high",
           "requester_name": "Петров П.П.",
           "department": "Цех №2",
           "contact_phone": "+7-911-222-33-44",
           "contact_email": "petrov@example.com"
         }'
   ```
2. Убедитесь, что ответ содержит `order_number` в формате `TORO-YYYY-NNN`.
3. Получите список заказов:
   ```bash
   curl http://localhost:5000/api/v1/orders
   ```

## 7. Работа с API

### 7.1 Создание заказа — `POST /api/v1/orders`
Обязательные поля: `equipment_type`, `equipment_id`, `issue_description`, `requester_name`, `department`, `contact_phone`, `contact_email`.
Необязательные: `priority` (по умолчанию `medium`). Статус и номер заявки выставляются на сервере.

Пример тела запроса:
```json
{
  "equipment_type": "Станок ЧПУ",
  "equipment_id": "CNC-001",
  "issue_description": "Система охлаждения перегревается",
  "priority": "high",
  "requester_name": "Иванов Иван",
  "department": "Цех №1",
  "contact_phone": "+7-900-123-45-67",
  "contact_email": "ivanov@example.com"
}
```

### 7.2 Список заказов — `GET /api/v1/orders`
Опциональные фильтры (query params):
- `priority` — `low|medium|high`
- `status` — `created|in_progress|completed`
- `department` — текстовый фильтр (регистр учитывается)

Ответ содержит массив `orders` и `total`:
```json
{
  "orders": [...],
  "total": 3
}
```

### 7.3 Получение заказа — `GET /api/v1/orders/<id>`
Возвращает заявку по `id`. При отсутствии ресурса — `404 Not Found`.

## 8. Правила валидации
- Все входные данные проходят через Pydantic-схемы (`schemas.py`), что гарантирует очистку пробелов и запрет лишних полей.
- Формат телефона строго `+7-XXX-XXX-XX-XX`.
- `contact_email` проверяется как корректный email (RFC-приблизительно) и обязателен.
- Недопустимые значения `priority`, `status`, фильтров или пустые строки вызовут `400 Bad Request` с деталями.

## 9. Обработка ошибок
| Код | Причина | Действия |
|-----|---------|----------|
| 400 | Невалидные данные или параметры | Проверьте обязательные поля и формат телефона |
| 404 | Заказ не найден | Убедитесь, что ID существует |
| 500 | Внутренняя ошибка | Просмотрите логи, убедитесь, что файл БД доступен |

Все ошибки возвращаются в JSON-формате: `{"error": "...", "message": "...", "details": {...}}`.

## 10. Администрирование и best practices
- **Резервное копирование**: периодически копируйте файл `toro.db`.
- **Перенос на прод**: задайте `TORO_DATABASE_URL` на внешний PostgreSQL/MySQL; Flask-SQLAlchemy прозрачно поддерживает драйверы SQLAlchemy.
- **Безопасность CORS**: перед публикой ограничьте список доменов в `CORS(app, resources={...})`.
- **Логи**: перенаправляйте stdout в систему логирования (journald/CloudWatch). Сообщения включают время, уровень и логгер `toro.api`.
- **Масштабирование**: запускайте приложение через WSGI/ASGI сервер (gunicorn, uWSGI). Переменная `app` доступна на модульном уровне (`app = Flask(__name__)`).

## 11. Часто задаваемые вопросы
- **Как сбросить базу?** Остановите приложение, удалите `toro.db`, затем запустите снова — таблица создастся автоматически.
- **Как изменить порт?** Укажите `FLASK_RUN_PORT` для `flask run` либо измените `app.run(port=5000)` (не рекомендуется без необходимости).
- **Можно ли добавлять поля?** Добавьте столбцы в модель `Order`, выполните миграцию (alembic) или пересоздайте SQLite при тестировании.

## 12. Контрольный список запуска
- [ ] Python 3.11 установлен.
- [ ] Создано виртуальное окружение и установлены зависимости.
- [ ] Настроено значение `TORO_DATABASE_URL` (опционально).
- [ ] Приложение запущено (`python app.py`) и лог сообщает о старте.
- [ ] Выполнены smoke-тесты `POST` + `GET`.

Следуя данному руководству, пользователь получает полностью рабочий сервис с комментариями в коде и понятной процедурой запуска.
